

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Reference &mdash; CellPyLib  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="License" href="license.html" />
    <link rel="prev" title="Additional Features" href="additional.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> CellPyLib
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Using CellPyLib</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="working.html">Working with Cellular Automata</a></li>
<li class="toctree-l1"><a class="reference internal" href="additional.html">Additional Features</a></li>
</ul>
<p class="caption"><span class="caption-text">API Docs and License</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-cellpylib.apen">cellpylib.apen</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cellpylib.bien">cellpylib.bien</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cellpylib.ca_functions">cellpylib.ca_functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cellpylib.ca_functions2d">cellpylib.ca_functions2d</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cellpylib.entropy">cellpylib.entropy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cellpylib.hopfield_net">cellpylib.hopfield_net</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cellpylib.rule_tables">cellpylib.rule_tables</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CellPyLib</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="reference">
<h1>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-cellpylib.apen">
<span id="cellpylib-apen"></span><h2>cellpylib.apen<a class="headerlink" href="#module-cellpylib.apen" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cellpylib.apen.apen">
<code class="sig-name descname"><span class="pre">apen</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.apen.apen" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Approximate Entropy, or ApEn, of the given sequence, as described in:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Pincus, S. M.; Gladstone, I. M.; Ehrenkranz, R. A. (1991).
&quot;A Regularity Statistic For Medical Data Analysis&quot;.
Journal of Clinical Monitoring and Computing. 7 (4): 335-345.
</pre></div>
</div>
<p>The implementation here is based on the Python implementation described in:
<a class="reference external" href="https://en.wikipedia.org/wiki/Approximate_entropy">https://en.wikipedia.org/wiki/Approximate_entropy</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> – a string of whole numbers, such as ‘012301’, or an array of whole numbers, such as [0,1,2,3,0,1],
or a numpy array of whole numbers</p></li>
<li><p><strong>m</strong> – the length of compared runs of data</p></li>
<li><p><strong>r</strong> – a filtering level</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real number, representing the approximate entropy (ApEn) for the given sequence</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-cellpylib.bien">
<span id="cellpylib-bien"></span><h2>cellpylib.bien<a class="headerlink" href="#module-cellpylib.bien" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cellpylib.bien.bien">
<code class="sig-name descname"><span class="pre">bien</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.bien.bien" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the BiEntropy of the given string, according to:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Croll, G. J. (2013). BiEntropy-The Approximate Entropy of a Finite Binary String.
arXiv preprint arXiv:1305.0954.
</pre></div>
</div>
<p>This version of BiEntropy is suitable for strings with length &lt;= 32.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>string</strong> – a binary string, such as ‘110011’</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real number representing the BiEntropy of the given string</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.bien.binary_derivative">
<code class="sig-name descname"><span class="pre">binary_derivative</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.bien.binary_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the binary derivative of the given string, according to:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Nathanson, M. B. (1971). Derivatives of binary sequences.
SIAM Journal on Applied Mathematics, 21(3), 407-412
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>string</strong> – a binary string, such as ‘110011’</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a binary string representing the binary derivative of the given string</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.bien.cyclic_binary_derivative">
<code class="sig-name descname"><span class="pre">cyclic_binary_derivative</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.bien.cyclic_binary_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the cyclic binary derivative, which is the “binary string of length n formed by XORing adjacent pairs of 
digits including the last and the first.” See:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Croll, G. J. (2018). The BiEntropy of Some Knots on the Simple Cubic Lattice.
arXiv preprint arXiv:1802.03772.
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>string</strong> – a binary string, such as ‘110011’</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a binary string representing the cyclic binary derivative of the given string</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.bien.ktbien">
<code class="sig-name descname"><span class="pre">ktbien</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.bien.ktbien" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the knot logarithmic weighting BiEntropy of the given string, according to:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Croll, G. J. (2018). The BiEntropy of Some Knots on the Simple Cubic Lattice.
arXiv preprint arXiv:1802.03772.
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>string</strong> – a binary string, such as ‘110011’</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real number representing the knot logarithmic weighting BiEntropy of the given string</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.bien.tbien">
<code class="sig-name descname"><span class="pre">tbien</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.bien.tbien" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the logarithmic weighting BiEntropy of the given string, according to:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Croll, G. J. (2013). BiEntropy-The Approximate Entropy of a Finite Binary String.
arXiv preprint arXiv:1305.0954.
</pre></div>
</div>
<p>This version of BiEntropy is suitable for strings with length &gt; 32.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>string</strong> – a binary string, such as ‘110011’</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real number representing the logarithmic weighting BiEntropy of the given string</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-cellpylib.ca_functions">
<span id="cellpylib-ca-functions"></span><h2>cellpylib.ca_functions<a class="headerlink" href="#module-cellpylib.ca_functions" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cellpylib.ca_functions.AsynchronousRule">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">AsynchronousRule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">apply_rule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_cells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">randomize_each_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.AsynchronousRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an asynchronous cellular automaton rule with a cyclic update scheme. Also known as a sequential cellular
automaton rule, in NKS. This rule wraps a given rule, making the given rule asynchronous. This rule works for 
both 1D and 2D cellular automata.</p>
<dl class="py method">
<dt id="cellpylib.ca_functions.AsynchronousRule.apply_rule">
<code class="sig-name descname"><span class="pre">apply_rule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.AsynchronousRule.apply_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cellpylib.ca_functions.ReversibleRule">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">ReversibleRule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule_number</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.ReversibleRule" title="Permalink to this definition">¶</a></dt>
<dd><p>An elementary cellular automaton rule explicitly set up to be reversible.</p>
<dl class="py method">
<dt id="cellpylib.ca_functions.ReversibleRule.apply_rule">
<code class="sig-name descname"><span class="pre">apply_rule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.ReversibleRule.apply_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions.binary_rule">
<code class="sig-name descname"><span class="pre">binary_rule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">neighbourhood</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scheme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">powers_of_two</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.binary_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the given rule number to a binary representation, and uses this to determine the value to return.
The process is approximately described as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>1. convert state to int, so [1,0,1] -&gt; 5, call this state_int

2. convert rule to binary, so 254 -&gt; [1,1,1,1,1,1,1,0], call this rule_bin_array

3. new value is rule_bin_array[7 - state_int]
   we subtract 7 from state_int to be consistent with the numbering scheme used in NKS
   in NKS, rule 254 for a 1D binary cellular automaton is described as:

  [1,1,1]  [1,1,0]  [1,0,1]  [1,0,0]  [0,1,1]  [0,1,0]  [0,0,1]  [0,0,0]
     1        1        1        1        1        1        1        0
</pre></div>
</div>
<p>If None is provided for the scheme parameter, the neighbourhoods are listed in lexicographic order (the reverse of
the NKS convention). If ‘nks’ is provided for the scheme parameter, the NKS convention is used for listing the 
neighbourhoods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>neighbourhood</strong> – a binary array of length 2r + 1</p></li>
<li><p><strong>rule</strong> – an int or a binary array indicating the cellular automaton rule number</p></li>
<li><p><strong>scheme</strong> – can be None (default) or ‘nks’; if ‘nks’ is given, the rule numbering scheme used in NKS is used</p></li>
<li><p><strong>powers_of_two</strong> – a pre-computed array containing the powers of two, e.g. [4,2,1]; can be None (default) or an
array of length len(neighbourhood); if an array is given, it will used to speed up the
calculation of state_int</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the result, 0 or 1, of applying the given rule on the given state</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions.bits_to_int">
<code class="sig-name descname"><span class="pre">bits_to_int</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.bits_to_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions.evolve">
<code class="sig-name descname"><span class="pre">evolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cellular_automaton</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timesteps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_rule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.evolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolves the given cellular automaton for the specified time steps. Applies the given function to each cell during
the evolution. A cellular automaton is represented here as an array of arrays, or matrix. This function expects
an array containing the initial time step (i.e. initial condition, an array) for the cellular automaton. The final
result is a matrix, where the number of rows equal the number of time steps specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cellular_automaton</strong> – the cellular automaton starting condition representing the first time step;
e.g. [[0,0,0,0,1,0,0,0,0]]</p></li>
<li><p><strong>timesteps</strong> – the number of time steps in this evolution; note that this value refers to the total number of
time steps in this cellular automaton evolution, which includes the initial condition</p></li>
<li><p><strong>apply_rule</strong> – a function representing the rule to be applied to each cell during the evolution; this function
will be given three arguments, in the following order: the neighbourhood, which is a numpy array
of length 2r + 1 representing the neighbourhood of the cell; the cell identity, which is a scalar
representing the index of the cell in the cellular automaton array; the time step, which is a 
scalar representing the time step in the evolution</p></li>
<li><p><strong>r</strong> – the neighbourhood radius; the neighbourhood size will be 2r + 1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a matrix, containing the results of the evolution, where the number of rows equal the number of time steps
specified</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions.init_random">
<code class="sig-name descname"><span class="pre">init_random</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">size</span></em>, <em class="sig-param"><span class="pre">k=2</span></em>, <em class="sig-param"><span class="pre">n_randomized=None</span></em>, <em class="sig-param"><span class="pre">empty_value=0</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'int'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.init_random" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a randomly initialized array with values consisting of numbers in {0,…,k - 1}, where k = 2 by default.
If dtype is not an integer type, then values will be uniformly distributed over the half-open interval [0, k - 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> – the size of the array to be created</p></li>
<li><p><strong>k</strong> – the number of states in the cellular automaton (2, by default)</p></li>
<li><p><strong>n_randomized</strong> – the number of randomized sites in the array; this value must be &gt;= 0 and &lt;= size, if specified;
if this value is not specified, all sites in the array will be randomized; the randomized sites
will be centered in the array, while all others will have an empty value</p></li>
<li><p><strong>empty_value</strong> – the value to use for non-randomized sites (0, by default)</p></li>
<li><p><strong>dtype</strong> – the data type</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a vector with shape (1, size), randomly initialized with numbers in {0,…,k - 1}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions.init_simple">
<code class="sig-name descname"><span class="pre">init_simple</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">size</span></em>, <em class="sig-param"><span class="pre">val=1</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'int'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.init_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array initialized with zeroes, with its center value set to the specified value, or 1 by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> – the size of the array to be created</p></li>
<li><p><strong>val</strong> – the value to be used in the center of the array (1, by default)</p></li>
<li><p><strong>dtype</strong> – the data type</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a vector with shape (1, size), with its center value initialized to the specified value, or 1 by default</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions.int_to_bits">
<code class="sig-name descname"><span class="pre">int_to_bits</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_digits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.int_to_bits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions.nks_rule">
<code class="sig-name descname"><span class="pre">nks_rule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">neighbourhood</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.nks_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function, that calls binary_rule with scheme = ‘nks’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>neighbourhood</strong> – a binary array of length 2r + 1</p></li>
<li><p><strong>rule</strong> – an int indicating the cellular automaton rule number</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the result, 0 or 1, of applying the given rule on the given state</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions.plot">
<code class="sig-name descname"><span class="pre">plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ca</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the given cellular automaton.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ca</strong> – the cellular automaton to plot</p></li>
<li><p><strong>title</strong> – the title to place on the plot</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions.plot_multiple">
<code class="sig-name descname"><span class="pre">plot_multiple</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ca_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">titles</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.plot_multiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots multiple cellular automata separately.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ca_list</strong> – a list of cellular automata</p></li>
<li><p><strong>titles</strong> – the titles to give the plots</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions.totalistic_rule">
<code class="sig-name descname"><span class="pre">totalistic_rule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">neighbourhood</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions.totalistic_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>The totalistic rule as described in NKS. The average color is mapped to a whole number in [0, k - 1].
The rule number is in base 10, but interpreted in base k. For a 1-dimensional cellular automaton, there are
3k - 2 possible average colors in the 3-cell neighbourhood. There are n(k - 1) + 1 possible average colors for a 
k-color cellular automaton with an n-cell neighbourhood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>neighbourhood</strong> – a k-color array of any size</p></li>
<li><p><strong>k</strong> – the number of colors in this cellular automaton, where only 2 &lt;= k &lt;= 36 is supported</p></li>
<li><p><strong>rule</strong> – the k-color cellular automaton rule number in base 10, interpreted in base k</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the result, a number from 0 to k - 1, of applying the given rule on the given state</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-cellpylib.ca_functions2d">
<span id="cellpylib-ca-functions2d"></span><h2>cellpylib.ca_functions2d<a class="headerlink" href="#module-cellpylib.ca_functions2d" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cellpylib.ca_functions2d.evolve2d">
<code class="sig-name descname"><span class="pre">evolve2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cellular_automaton</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timesteps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_rule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbourhood</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Moore'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions2d.evolve2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolves the given cellular automaton for the specified time steps. Applies the given function to each cell during
the evolution. A cellular automaton is represented here as an array of arrays, or matrix. This function expects
an array containing the initial time step (i.e. initial condition, an array) for the cellular automaton. The final
result is a matrix, where the number of rows equal the number of time steps specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cellular_automaton</strong> – the cellular automaton starting condition representing the first time step</p></li>
<li><p><strong>timesteps</strong> – the number of time steps in this evolution; note that this value refers to the total number of
time steps in this cellular automaton evolution, which includes the initial condition</p></li>
<li><p><strong>apply_rule</strong> – a function representing the rule to be applied to each cell during the evolution; this function
will be given three arguments, in the following order: the neighbourhood, which is a numpy
2D array of dimensions 2r+1 x 2r+1, representing the neighbourhood of the cell (if the
‘von Neumann’ neighbourhood is specified, the array will be a masked array); the cell identity,
which is a tuple representing the row and column indices of the cell in the cellular automaton
matrix, as (row, col); the time step, which is a scalar representing the time step in the
evolution</p></li>
<li><p><strong>r</strong> – the neighbourhood radius; the neighbourhood dimensions will be 2r+1 x 2r+1</p></li>
<li><p><strong>neighbourhood</strong> – the neighbourhood type; valid values are ‘Moore’ or ‘von Neumann’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of matrices, containing the results of the evolution, where the number of rows equal the number
of time steps specified</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions2d.game_of_life_rule">
<code class="sig-name descname"><span class="pre">game_of_life_rule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">neighbourhood</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions2d.game_of_life_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Conway’s Game of Life rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>neighbourhood</strong> – the current cell’s neighbourhood</p></li>
<li><p><strong>c</strong> – the index of the current cell</p></li>
<li><p><strong>t</strong> – the current timestep</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the state of the current cell at the next timestep</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions2d.init_random2d">
<code class="sig-name descname"><span class="pre">init_random2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">rows</span></em>, <em class="sig-param"><span class="pre">cols</span></em>, <em class="sig-param"><span class="pre">k=2</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'int'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions2d.init_random2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a randomly initialized matrix with values consisting of numbers in {0,…,k - 1}, where k = 2 by default.
If dtype is not an integer type, then values will be uniformly distributed over the half-open interval [0, k - 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rows</strong> – the number of rows in the matrix</p></li>
<li><p><strong>cols</strong> – the number of columns in the matrix</p></li>
<li><p><strong>k</strong> – the number of states in the cellular automaton (2, by default)</p></li>
<li><p><strong>dtype</strong> – the data type</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tensor with shape (1, rows, cols), randomly initialized with numbers in {0,…,k - 1}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions2d.init_simple2d">
<code class="sig-name descname"><span class="pre">init_simple2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">rows</span></em>, <em class="sig-param"><span class="pre">cols</span></em>, <em class="sig-param"><span class="pre">val=1</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'int'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions2d.init_simple2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matrix initialized with zeroes, with its center value set to the specified value, or 1 by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rows</strong> – the number of rows in the matrix</p></li>
<li><p><strong>cols</strong> – the number of columns in the matrix</p></li>
<li><p><strong>val</strong> – the value to be used in the center of the matrix (1, by default)</p></li>
<li><p><strong>dtype</strong> – the data type</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tensor with shape (1, rows, cols), with the center value initialized to the specified value, or 1 by default</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions2d.plot2d">
<code class="sig-name descname"><span class="pre">plot2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ca</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions2d.plot2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the state of the given 2D cellular automaton at the given timestep.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ca</strong> – the 2D cellular automaton to plot</p></li>
<li><p><strong>timestep</strong> – the timestep of interest</p></li>
<li><p><strong>title</strong> – the title to place on the plot</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions2d.plot2d_animate">
<code class="sig-name descname"><span class="pre">plot2d_animate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ca</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions2d.plot2d_animate" title="Permalink to this definition">¶</a></dt>
<dd><p>Animate the given 2D cellular automaton.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ca</strong> – the 2D cellular automaton to animate</p></li>
<li><p><strong>title</strong> – the title to place on the plot</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions2d.plot2d_slice">
<code class="sig-name descname"><span class="pre">plot2d_slice</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ca</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions2d.plot2d_slice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="cellpylib.ca_functions2d.plot2d_spacetime">
<code class="sig-name descname"><span class="pre">plot2d_spacetime</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ca</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.ca_functions2d.plot2d_spacetime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-cellpylib.entropy">
<span id="cellpylib-entropy"></span><h2>cellpylib.entropy<a class="headerlink" href="#module-cellpylib.entropy" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cellpylib.entropy.average_cell_entropy">
<code class="sig-name descname"><span class="pre">average_cell_entropy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cellular_automaton</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.entropy.average_cell_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the average cell entropy in the given cellular automaton, where entropy is the Shannon entropy.
In the case of a 1D cellular automaton, the state of a cell over time is represented as a string, and its entropy
is calculated. The same is done for all cells in this cellular automaton, and the average entropy is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cellular_automaton</strong> – the cellular automaton to perform this operation on</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real number representing the average cell Shannon entropy</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.entropy.average_mutual_information">
<code class="sig-name descname"><span class="pre">average_mutual_information</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cellular_automaton</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temporal_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.entropy.average_mutual_information" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the average mutual information between a cell and itself at the next n time steps, given by the 
specified temporal distance. A temporal distance of 1 means the next time step.</p>
<p>For example, consider the following string, ‘00101010110’, which represents the state of a cell over 11 time steps.
The strings which will be used for the computation of the mutual information between a cell and itself at the
next time step are: ‘0010101011’ and ‘0101010110’, since we pair each time-step value with its next value:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&quot; 00101010110&quot;
&quot;00101010110 &quot;
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cellular_automaton</strong> – the cellular automaton to perform this operation on</p></li>
<li><p><strong>temporal_distance</strong> – the size of temporal separation, where the value must be greater than 0 and
less than the number of time steps.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real number representing the average mutual information between a cell and itself at the next time step</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.entropy.joint_shannon_entropy">
<code class="sig-name descname"><span class="pre">joint_shannon_entropy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stringX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stringY</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.entropy.joint_shannon_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the joint Shannon entropy between the given strings, which must be of the same length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stringX</strong> – any string, such as ‘000101001’, ‘12402’, or ‘aBcd1234ef5g’</p></li>
<li><p><strong>stringY</strong> – any string, such as ‘000101001’, ‘12402’, or ‘aBcd1234ef5g’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real number representing the joint Shannon entropy between the given strings</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.entropy.mutual_information">
<code class="sig-name descname"><span class="pre">mutual_information</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stringX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stringY</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.entropy.mutual_information" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mutual information between the given strings, which must be of the same length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stringX</strong> – any string, such as ‘000101001’, ‘12402’, or ‘aBcd1234ef5g’</p></li>
<li><p><strong>stringY</strong> – any string, such as ‘000101001’, ‘12402’, or ‘aBcd1234ef5g’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real number representing the mutual information between the given strings</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.entropy.shannon_entropy">
<code class="sig-name descname"><span class="pre">shannon_entropy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.entropy.shannon_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Shannon entropy for the given string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>string</strong> – any string, such as ‘000101001’, ‘12402’, or ‘aBcd1234ef5g’</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real number representing the Shannon entropy</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-cellpylib.hopfield_net">
<span id="cellpylib-hopfield-net"></span><h2>cellpylib.hopfield_net<a class="headerlink" href="#module-cellpylib.hopfield_net" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cellpylib.hopfield_net.HopfieldNet">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HopfieldNet</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_cells</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.hopfield_net.HopfieldNet" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="cellpylib.hopfield_net.HopfieldNet.W">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">W</span></code><a class="headerlink" href="#cellpylib.hopfield_net.HopfieldNet.W" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="cellpylib.hopfield_net.HopfieldNet.r">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">r</span></code><a class="headerlink" href="#cellpylib.hopfield_net.HopfieldNet.r" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="cellpylib.hopfield_net.HopfieldNet.train">
<code class="sig-name descname"><span class="pre">train</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.hopfield_net.HopfieldNet.train" title="Permalink to this definition">¶</a></dt>
<dd><p>The training set consists of patterns to be learned by this net. The patterns should be composed of 
bipolar ({-1,1}), and not binary ({0,1}), values.
:param P: the set of training patterns</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cellpylib.rule_tables">
<span id="cellpylib-rule-tables"></span><h2>cellpylib.rule_tables<a class="headerlink" href="#module-cellpylib.rule_tables" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cellpylib.rule_tables.random_rule_table">
<code class="sig-name descname"><span class="pre">random_rule_table</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quiescent_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strong_quiescence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.rule_tables.random_rule_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs and returns a random rule table using the “random-table” method, as described in:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Langton, C. G. (1990). Computation at the edge of chaos: phase transitions
and emergent computation.
Physica D: Nonlinear Phenomena, 42(1-3), 12-37.
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> – the number of cell states</p></li>
<li><p><strong>r</strong> – the radius of the cellular automaton neighbourhood</p></li>
<li><p><strong>lambda_val</strong> – a real number in (0., 1.), representing the value of lambda; if None, a default value of
1.0 - 1/k will be used, where all states will be represented equally in the rule table</p></li>
<li><p><strong>quiescent_state</strong> – the state, a number in {0,…,k - 1}, to use as the quiescent state</p></li>
<li><p><strong>strong_quiescence</strong> – if True, all neighbourhood states uniform in cell state i will map to cell state i</p></li>
<li><p><strong>isotropic</strong> – if True, all planar rotations of a neighbourhood state will map to the same cell state</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple containing: a table describing a rule, constructed using the “random-table” table method as
described by C. G. Langton, the actual lambda value, and the quiescent state used</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.rule_tables.table_rule">
<code class="sig-name descname"><span class="pre">table_rule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">neighbourhood</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">table</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.rule_tables.table_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>A rule where the state is converted into a string, and looked up in the given table, to yield the return value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>neighbourhood</strong> – a k-color array of length 2r + 1</p></li>
<li><p><strong>table</strong> – a table (map) of string representations of each neighbourhood state to the associated next
cell state value; for example, for k = 2 and r = 2, a valid table might be: 
{‘101’: 1, ‘111’: 0, ‘011’: 0, ‘110’: 1, ‘000’: 0, ‘100’: 0, ‘010’: 0, ‘001’: 1}</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a number, from 0 to k - 1, associated with the given state as specified in the given table</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="cellpylib.rule_tables.table_walk_through">
<code class="sig-name descname"><span class="pre">table_walk_through</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rule_table</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quiescent_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strong_quiescence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cellpylib.rule_tables.table_walk_through" title="Permalink to this definition">¶</a></dt>
<dd><p>Perturbs the given rule table using the “table-walk-through” approach described in:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Langton, C. G. (1990). Computation at the edge of chaos: phase transitions
and emergent computation.
Physica D: Nonlinear Phenomena, 42(1-3), 12-37.
</pre></div>
</div>
<p>The table’s actual lambda value will be increased or decreased, incrementally and stochastically, until it reaches
the given lambda value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rule_table</strong> – a table (map) of string representations of each neighbourhood state to the associated next 
cell state value; for example, for k = 2 and r = 2, a valid table might be: 
{‘101’: 1, ‘111’: 0, ‘011’: 0, ‘110’: 1, ‘000’: 0, ‘100’: 0, ‘010’: 0, ‘001’: 1}</p></li>
<li><p><strong>lambda_val</strong> – a real number in (0., 1.), representing the value of lambda</p></li>
<li><p><strong>k</strong> – the number of cell states</p></li>
<li><p><strong>r</strong> – the radius of the cellular automaton neighbourhood</p></li>
<li><p><strong>quiescent_state</strong> – the state, a number in {0,…,k - 1}, to use as the quiescent state</p></li>
<li><p><strong>strong_quiescence</strong> – if True, all neighbourhood states uniform in cell state i will map to cell state i</p></li>
<li><p><strong>isotropic</strong> – if True, all planar rotations of a neighbourhood state will map to the same cell state</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple containing: a table describing a rule, constructed using the “table-walk-through” method as
described by C. G. Langton, the actual lambda value</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="license.html" class="btn btn-neutral float-right" title="License" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="additional.html" class="btn btn-neutral float-left" title="Additional Features" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Luis M. Antunes.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>